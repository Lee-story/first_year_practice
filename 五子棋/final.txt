1.程式架構(邏輯):
設函式
把情況都用危險值取代。
檢查點的周圍(左上、上、右上、右、右下、下、左下、左)共9個位置，然後判斷。
攻擊、防守、活三的函式都雷同


/------------------------防守函式defense------------------------/

假設對方下棋為中間board[5][5]
以檢查左邊為例
把棋的位置位移左邊5格


int c=0;					C為危險值，當下方每一個的判斷式都符合時，C會加一
if(y!=0)	
for(int k=y;k>=y-5;k--){往左移
if(k==0)break;
if(board[x][k-1]==0||board[x][k-1]==player)break;如果是自己方的棋就會跳出
else if(board[x][k-1]==player2)c++;              如果是敵方的危險值就會加一
.
.
.
.
.
.
D[x][y]=c*10;                                    最後c的總值會乘10，帶入後會在防守危險值D[x][y]

/------------------------活三函式three-----------------------/

		
int d=0;紀錄棋的數量
if(y!=0)
{
for(int p=y;p>=y-4;p--){
if(p==-1)break;
else if(board[x][p]==player2)d++;
if(d==3&&board[x][p]==0){
D[x][y]+=40;					判斷後如果有活三會在防守危險值D[x][y]加40
break;
}
else if(board[x][p]==player){
D[x][y]=0;					沒有的話就會d就會歸零
d=0;
break;	
}
			
}
}
/------------------------帶入值determine1------------------------/
	 
	if(D[x][y]>=maxD)
	{
	maxD=D[x][y];				先儲存值到maxD為了後面的判斷式
	dx=x;
	dy=y;
	}
	

/------------------------攻擊attack------------------------/
	 

假設我方下棋為中間board[5][5]
以檢查左邊為例
把棋的位置位移左邊5格


int c=0;					C為確定值，當下方每一個的判斷式都符合時，C會加1
if(y!=0)
for(int k=y;k>=y-5;k--){ 
if(k==0)break;
if(board[x][k-1]==player2||board[x][k-1]==0)break;
else if(board[x][k-1]==player)c++; 		為自己方的棋，c就加1
.
.
.
.
.
.
A[x][y]=c*10;					最後c的總值會乘10，帶入後會在攻擊確定值D[x][y]
/------------------------帶入值determine2------------------------/

 	if(A[x][y]>=maxA)
	{
	maxA=A[x][y];				先儲存值到maxA為了後面的判斷式
	ax=x;
	ay=y;
	}

在主程式main裡依順序執行上防提的函式，然後下方再決定總值。

if(board[5][5]==0)				當我方式先攻時，會下board[5][5]這個位置
	{
	valuex=5;valuey=5; 
}
由上面儲存的值比大小，判斷進攻還是防守何者為最佳選擇，從兩者中選其中一個值帶入輸入棋盤的函式。
	else if(maxD>=maxA)			
	{
		valuex=dx;
		valuey=dy; 
	}
	else
	{
		valuex=ax;
		valuey=ay;
	}

2.策略:

沒有策略，單純判斷防守危險值和攻擊確定值而下棋，算是比較保守又單一的程式。









